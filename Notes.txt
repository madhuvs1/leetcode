1)LongestConsecutiveSequence -> Input:  [100,4,200,1,3,2]	Output: 4.  Technique: a) Find the anchor (no predecessor | number-1 exists) b) Use HashSet (doesn't allow duplicates)
2)TwoSum -> Input: [2,7,11,15], target = 9 output: 0,1 (indices provides sum = 9) Technique: HashMap Complement lookup
3)LongestSubstring: Input: s = "abcabcbb" output: 3 Technique: a) User Left and Right Pointers, Right expands, when there is a duplicate within the Left-Right pointers range, Left Pointer jumps past the duplicate character index.
4)Longest Palindrome substring: s = "babad" Output: "bab" | s = "abbac" output: abba Technique: Expand around center, a) for odd palindromes start left and right with 1, 
and for even palindromes (cbba) try left with 1 and right with left+1. For any given string try both odd and even, as possible to have even palindrome in odd string.
5)CloneGraph, input: Node output: Deep ClonedNode. Technique uses a hashmap to stores node and its neighbors, when filling in the neighbors use DFS(Depth First Search) recursively calling method and fulfill the neighbors
6)Palindromic Substrings -> Input: abc Output: 3 Explanation: Three palindromic strings: "a", "b", "c". Technique: Expand around center, a) for odd palindromes start left and right with 1, 
7)Container with Most water -> Input: height = [1,8,6,2,5,4,8,3,7] formula: width(l-r)*containerHeight(min(height[l],height[r])) Technique: 2 pointer technique, while l is shorter move forward l++, otherwise move r inward r--
8)WordBreak->Input s = "leetcode", wordDict = ["leet","code"] output: true, Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"] Output: false Technique: Use BFS, Queue, Checkpoint, Checkpoint indices more details in the class file
9)LinkedListCycle-> Input: head = [3,2,0,-4] POS-1, meaning -4 the tail points to index 1 creating a cycle Output: true if there is a cycle. Technique: User HashMap, but preferred to use Floyd's cycle detection Algorithm (tortoise and hare).
10)MissingNumber -> Input: nums = [3,0,1] Output: 2 |Input: nums = [0,1] Output: 2 Technique: we can use XOR bitwise operator. XOR logically returns bit 1 only when X^Y is different, 
also its a pairwise cancelling machine. meaning if you 2 ^ 2 it becomes 0. From the given input array if you do inputArray ^ actualArray -> returns missing as XOR cancels (clears) matching values so you can find missing number.
11)ThreeSum -> Given an integer array nums, return all the triplets and nums[i] + nums[j] + nums[k] == 0, triplet combination needs to be unique. 
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Input: nums = [0,1,1] Output: [] Technique: Sort the Array, use LeftPointer(++) and RightPointer(--), for loop start with length-2 so you have room for pointers. 
12)ReorderList Input: head = [1,2,3,4] output: L0 → L1 → … → Ln - 1 → Ln Output: [1,4,2,3] Input: head = [1,2,3,4,5] Output: [1,5,2,4,3] 
Technique: Split the LinkedList by half by slow and fast pointer, Reverse the second half, Merge First and Second Half
13)RemoveNthNodeFromEnd: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Input: head = [1], n = 1 Output: []
Technique: Use Anchor Node(dummy) point its next to head, use 2 pointer, Fast Pointer and slowPointer are pointed to dummyNode, FastPointers moves forward to N+1 steps 
Next move fast and slow pointer by 1 step until fastPointer is not null. At this stage, SlowPointer.next is the node to be removed, slowPointer.next = slowPointer.next.next and return dummyNode.next;
14)ValidParenthesis: Input: s = "()" Output: true Input: s= "){" Output: false Input: ()[]{} output: false Input: ()[]{}  Output: false
Technique: Create Map of pair of parenthesis, use a Stack to add each parenthesis, if you encounter a closing parenthesis in the array and the stack peed doesn't have its pair then its invalid.