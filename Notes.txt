1)LongestConsecutiveSequence -> Input:  [100,4,200,1,3,2]	Output: 4.  Technique: a) Find the anchor (no predecessor | number-1 exists) b) Use HashSet (doesn't allow duplicates)
2)TwoSum -> Input: [2,7,11,15], target = 9 output: 0,1 (indices provides sum = 9) Technique: HashMap Complement lookup
3)LongestSubstring: Input: s = "abcabcbb" output: 3 Technique: a) User Left and Right Pointers, Right expands, when there is a duplicate within the Left-Right pointers range, Left Pointer jumps past the duplicate character index.
4)Longest Palindrome substring: s = "babad" Output: "bab" | s = "abbac" output: abba Technique: Expand around center, a) for odd palindromes start left and right with 1, 
and for even palindromes (cbba) try left with 1 and right with left+1. For any given string try both odd and even, as possible to have even palindrome in odd string.
5)CloneGraph, input: Node output: Deep ClonedNode. Technique uses a hashmap to stores node and its neighbors, when filling in the neighbors use DFS(Depth First Search) recursively calling method and fulfill the neighbors
6)Palindromic Substrings -> Input: abc Output: 3 Explanation: Three palindromic strings: "a", "b", "c". Technique: Expand around center, a) for odd palindromes start left and right with 1, 
7)Container with Most water -> Input: height = [1,8,6,2,5,4,8,3,7] formula: width(l-r)*containerHeight(min(height[l],height[r])) Technique: 2 pointer technique, while l is shorter move forward l++, otherwise move r inward r--
