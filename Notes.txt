1)LongestConsecutiveSequence -> Input:  [100,4,200,1,3,2]	Output: 4.  Technique: a) Find the anchor (no predecessor | number-1 exists) b) Use HashSet (doesn't allow duplicates)
2)TwoSum -> Input: [2,7,11,15], target = 9 output: 0,1 (indices provides sum = 9) Technique: HashMap Complement lookup
3)LongestSubstring: Input: s = "abcabcbb" output: 3 Technique: a) User Left and Right Pointers, Right expands, when there is a duplicate within the Left-Right pointers range, Left Pointer jumps past the duplicate character index.
4)Longest Palindrome substring: s = "babad" Output: "bab" | s = "abbac" output: abba Technique: Expand around center, a) for odd palindromes start left and right with 1, 
and for even palindromes (cbba) try left with 1 and right with left+1. For any given string try both odd and even, as possible to have even palindrome in odd string.
5)CloneGraph, input: Node output: Deep ClonedNode. Technique uses a hashmap to stores node and its neighbors, when filling in the neighbors use DFS(Depth First Search) recursively calling method and fulfill the neighbors
6)Palindromic Substrings -> Input: abc Output: 3 Explanation: Three palindromic strings: "a", "b", "c". Technique: Expand around center, a) for odd palindromes start left and right with 1, 
7)Container with Most water -> Input: height = [1,8,6,2,5,4,8,3,7] formula: width(l-r)*containerHeight(min(height[l],height[r])) Technique: 2 pointer technique, while l is shorter move forward l++, otherwise move r inward r--
8)WordBreak->Input s = "leetcode", wordDict = ["leet","code"] output: true, Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"] Output: false Technique: Use BFS, Queue, Checkpoint, Checkpoint indices more details in the class file
9)LinkedListCycle-> Input: head = [3,2,0,-4] POS-1, meaning -4 the tail points to index 1 creating a cycle Output: true if there is a cycle. Technique: User HashMap, but preferred to use Floyd's cycle detection Algorithm (tortoise and hare).
10)MissingNumber -> Input: nums = [3,0,1] Output: 2 |Input: nums = [0,1] Output: 2 Technique: we can use XOR bitwise operator. XOR logically returns bit 1 only when X^Y is different, 
also its a pairwise cancelling machine. meaning if you 2 ^ 2 it becomes 0. From the given input array if you do inputArray ^ actualArray -> returns missing as XOR cancels (clears) matching values so you can find missing number.